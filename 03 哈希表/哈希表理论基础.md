# 哈希表
根据关键码的值而直接进行访问的数据结构
例如：数组，根据索引下标，直接访问数组中的元素，所以数组就是一张哈希表

哈希表可以用来快速判断一个元素是否出现集合里
例如：要查询一个名字是否在学校里，枚举的时间复杂度是O(n)，但是哈希可以O(1)
但前提是，要先把这个学校里的所有学生都映射到哈希表里。

# 哈希函数
取模？
问：为什么当学生的数量大于哈希表的大小，会出现几位学生的名字同时映射到哈希表同一个索引下标的位置？

# 哈希碰撞
两位同学都映射到同一个索引下标上
## 拉链法
发生冲突的元素存储在链表中
## 线性探测法
一定要保证tableSize大于dataSize，那既然哈希表比较大，那怎么还会有哈希碰撞呢

# 常见的三种哈希结构
（此处涉及到了对语言容器底层的理解
## 数组
## set（集合）
std::unordered_set底层实现为哈希表，
std::set 和std::multiset 的底层实现是红黑树，
红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

使用集合来解决哈希问题的时候：
优先使用unordered_set，因为它的查询和增删效率是最优的，
如果需要集合是有序的，那么就用set，
如果要求不仅有序还要有重复数据的话，那么就用multiset

## map（映射）
std::unordered_map 底层实现为哈希表，
std::map 和std::multimap 的底层实现是红黑树。
同理，std::map 和std::multimap 的key也是有序的

在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

# 总结
当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。
但是哈希法也是牺牲了空间换取了时间，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。





